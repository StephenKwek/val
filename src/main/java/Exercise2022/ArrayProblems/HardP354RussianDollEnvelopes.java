package Exercise2022.ArrayProblems;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * 354. Russian Doll Envelopes (Hard)
 * You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width
 * and the height of an envelope.
 *
 * One envelope can fit into another if and only if both the width and height of one envelope are greater
 * than the other envelope's width and height.
 *
 * Return the maximum number of envelops you can Russian doll (i.e., put one inside the other).
 *
 * https://leetcode.com/problems/russian-doll-envelopes/
 * Note: You cannot rotate an envelope.
 */
public class HardP354RussianDollEnvelopes {
    private int dfs(int[][] G, Integer root) {
        long start = System.nanoTime();
        //Stack<Integer> s = new Stack<>();
        int[] s = G.length > 10000 ? new int[G.length] : new int[10 * G.length];
        int pointer = 0;
        int[] seen = new int[G.length];
        int[] processed = new int[G.length]; // for efficiency
        s[pointer++] = 0;
        seen[root] = 1;
        int maxDepth = 1;
        while (pointer > 0) {
            int cur = s[--pointer];
            if (processed[cur] < seen[cur]) {
                processed[cur] = seen[cur];
                for (int w : G[cur]) {
                    int nextDepth = (int) (seen[cur] + 1);
                    if (processed[w] < nextDepth && seen[w] < nextDepth) {
                        if (pointer >= s.length) {
                            pointer = 0;
                            boolean[] appeared = new boolean[G.length];
                            for (int e : s) {
                                if (!appeared[e]) {
                                    s[pointer++] = e;
                                    appeared[e] = true;
                                }
                            }
                            if (pointer >= s.length) {
                                System.out.println(s.length);
                                s = Arrays.copyOf(s, 2 * s.length);
                            }
                        }
                        s[pointer++] = w;
                        maxDepth = (int) Math.max(maxDepth, nextDepth);
                    }
                    seen[w] = nextDepth;
                }
            }
        }
        System.out.println("dfs time:" + (System.nanoTime() - start));
        return (int) (maxDepth - 1);
    }

    public int maxEnvelopes(int[][] envelopes) {
        int[][] G = getG(envelopes);
        return dfs(G, 0);
    }

    // construct graph
    private int[][] getG(int[][] envelopes) {
        long start = System.nanoTime();
        Arrays.sort(envelopes, Comparator.comparingInt(o -> o[1]));
        Arrays.sort(envelopes, Comparator.comparingInt(o -> o[0]));
        int n = (int) envelopes.length;
        boolean[] nonRoots = new boolean[n];
        //List<Integer>[] G = new ArrayList[n+1];
        //int[][] A = new int[n+1][];
        int[][] A = new int[n+1][];
        int[] tmp = new int[n+1];
        for (int i = 1; i <= n; i++) {
            //G[i] = new ArrayList<>();
            int pointer = 0;
            for (int j = i-1; j >= 1; j--) {
            //for (int j = i - 1; j > 0; j--) {
                if (envelopes[i-1][0] > envelopes[j-1][0] && envelopes[i-1][1] > envelopes[j-1][1]
                    && !(pointer >= 1
                         && A[tmp[0]] != null && A[tmp[0]].length > 0
                         && envelopes[tmp[0] - 1][0] > envelopes[j - 1][0]
                         && envelopes[tmp[0] - 1][1] > envelopes[j - 1][1])) {
                    tmp[pointer++] = j;
                    nonRoots[j - 1] = true;
                }
                /*
                if (envelopes[i-1][0] > envelopes[j-1][0] && envelopes[i-1][1] > envelopes[j-1][1]) {
                    //G[i].add(j);
                    boolean isGrandChild = false;
                    if (pointer >= 1)  {
                        //int last = tmp[pointer - 1];
                        int last = tmp[0];
                        //isGrandChild = (A[last] != null && A[last].length > 0 && A[last][A[last].length - 1] == j);
                        isGrandChild = (A[last] != null && A[last].length > 0
                                && envelopes[last - 1][0] > envelopes[j - 1][0]
                                && envelopes[last - 1][1] > envelopes[j - 1][1]);
                    }
                    if (!isGrandChild) {
                        tmp[pointer++] = j;
                        nonRoots[j - 1] = true;
                    }
                }
                 */
            }
            A[i] = Arrays.copyOf(tmp, pointer);
            //G[i].sort(Comparator.comparingInt(u -> envelopes[u-1][0] * envelopes[u-1][1]));
            //Collections.reverse(G[i]);
        }
        List<Integer> roots = IntStream.range(0, nonRoots.length)
                .filter(i -> !nonRoots[i])
                .mapToObj(i -> i)
                .collect(Collectors.toList());
        A[0] = new int[roots.size()];
        for (int i = 0; i < roots.size(); i++) {
            A[0][i] = (roots.get(i) + 1);
        }
        System.out.println("G time:" + (System.nanoTime() - start));
        return A;
    }

    public static void main(String[] args) {
        HardP354RussianDollEnvelopes p = new HardP354RussianDollEnvelopes();
        int[][] envelopes7 = {{1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,6}, {7,7}};
        assert 7  == p.maxEnvelopes(envelopes7);
        int[][] envelopes6 = {{936,357},{742,148},{643,776},{612,34},{897,140},{33,508},{160,35},{456,191},{620,496},
                {220,898},{302,940},{964,767},{721,327},{176,423},{14,345},{182,616},{753,459},{780,480},{488,103},
                {36,657},{288,942},{807,831},{438,880},{984,342},{738,780},{326,599},{380,915},{106,299},{413,428},
                {703,795},{155,362},{809,764},{269,392},{393,379},{690,793},{362,249},{229,519},{515,98},{611,817},
                {460,925},{463,784},{490,585},{120,987},{8,298},{486,144},{655,407},{907,786},{275,998},{241,565},
                {96,305},{351,393},{65,971},{200,485},{162,91},{150,423},{944,524},{574,216},{949,729},{711,38},{677,115},{228,779},{783,984},{868,22},{463,743},{495,727},{720,319},{900,470},{759,663},{958,622},{231,798},{98,987},{551,367},{789,689},{729,413},{946,118},{863,84},{637,158},{300,629},{958,53},{655,819},{390,2},{298,764},{133,828},{477,695},{667,690},{943,731},{311,998},{412,366},{388,238},{321,417},{309,12},{554,589},{989,521},{73,752},{76,343},{754,159},{206,600},{793,367},{593,711},{475,976},{917,31},{933,556},{228,343},{174,810},{368,532},{552,397},{649,672},{74,439},{917,259},{622,38},{140,14},{660,497},{117,10},{437,957},{791,487},{782,475},{869,207},{258,375},{576,334},{393,812},{759,38},{604,289},{991,786},{597,125},{651,91},{960,351},{788,379},{829,920},{448,809},{404,88},{689,172},{923,345},{139,452},{260,375},{237,190},{266,921},{798,935},{715,827},{87,309},{305,572},{554,167},{33,642},{862,978},{313,951},{583,346},{514,629},{638,589},{684,430},{802,841},{366,419},{9,866},{339,805},{46,108},{914,674},{498,700},{51,966},{446,632},{161,537},{394,837},{83,549},{46,314},{158,568},{743,118},{305,728},{906,52},{497,81},{902,14},{887,338},{328,204},{423,820},{91,678},{817,584},{332,645},{679,71},{142,722},{450,654},{53,613},{41,654},{730,868},{798,89},{155,532},{488,673},{404,263},{1000,750},{569,137},{417,866},{543,545},{146,378},{417,721},{681,862},{147,861},{935,554},{288,669},{857,304},{638,787},{965,429},{222,68},{577,970},{771,75},{207,20},{77,609},{296,441},{979,797},{573,345},{410,385},{868,487},{382,836},{196,563},{755,287},{346,316},{82,34},{515,484},{703,300},{159,206},{582,59},{20,683},{2,787},{773,398},{960,870},{641,403},{695,833},{331,851},{633,983},{529,868},{41,93},{765,602},{403,583},{871,359},{342,832},{509,685},{289,626},{887,32},{232,866},{863,419},{393,680},{90,979},{555,290},{498,954},{336,818},{953,939},{490,654},{690,971},{964,4},{145,894},{136,658},{448,371},{323,991},{873,786},{718,337},{988,111},{480,449},{891,544},{867,529},{965,13},{712,686},{369,29},{112,35},{391,662},{552,832},{562,1},{490,906},{795,676},{87,670},{423,994},{615,338},{639,947},{118,927},{850,411},{467,568},{844,205},{760,446},{46,905},{28,855},{856,781},{485,349},{92,217},{814,299},{601,123},{622,4},{802,566},{917,327},{569,882},{39,885},{456,217},{372,882},{862,864},{7,29},{855,562},{909,79},{630,706},{519,63},{225,757},{89,880},{179,623},{309,839},{364,550},{253,73},{578,628},{895,534},{606,607},{166,547},{578,657},{695,841},{203,112},{805,918},{61,877},{384,781},{224,217},{142,10},{516,894},{575,263},{379,968},{825,52},{53,88},{19,169},{206,463},{461,697},{308,196},{902,103},{62,665},{397,369},{79,878},{486,869},{633,847},{222,939},{246,957},{461,609},{251,28},{477,650},{650,262},{362,571},{675,843},{39,972},{312,395},{833,797},{167,397},{554,594},{129,224},{808,135}};
        assert 28  == p.maxEnvelopes(envelopes6);


        int[][] envelopes5 = {{856,533},{583,772},{980,524},{203,666},{987,151},{274,802},{982,85},{359,160},{58,823},{512,381},{796,655},{341,427},{145,114},{76,306},{760,929},{836,751},{922,678},{128,317},{185,953},{115,845},{829,991},{93,694},{317,434},{818,571},{352,638},{926,780},{819,995},{54,69},{191,392},{377,180},{669,952},{588,920},{335,316},{48,769},{188,661},{916,933},{674,308},{356,556},{350,249},{686,851},{600,178},{849,439},{597,181},{80,382},{647,105},{4,836},{901,907},{595,347},{214,335},{956,382},{77,979},{489,365},{80,220},{859,270},{676,665},{636,46},{906,457},{522,769},{2,758},{206,586},{444,904},{912,370},{64,871},{59,409},{599,238},{437,58},{309,767},{258,440},{922,369},{848,650},{478,76},{84,704},{314,207},{138,823},{994,764},{604,595},{537,876},{877,253},{945,185},{623,497},{968,633},{172,705},{577,388},{819,763},{409,905},{275,532},{729,593},{547,226},{445,495},{398,544},{243,500},{308,24},{652,452},{93,885},{75,884},{243,113},{600,555},{756,596},{892,762},{402,653},{916,975},{770,220},{455,579},{889,68},{306,899},{567,290},{809,653},{92,329},{370,861},{632,754},{321,689},{190,812},{88,701},{79,310},{917,91},{751,480},{750,39},{781,978},{778,912},{946,559},{529,621},{55,295},{473,748},{646,854},{930,913},{116,734},{647,812},{426,172},{122,14},{522,843},{88,308},{719,602},{712,928},{303,890},{973,886},{276,354},{660,720},{708,387},{776,605},{653,815},{448,285},{549,959},{139,365},{74,952},{372,424},{642,504},{361,901},{620,612},{313,301},{397,225},{446,716},{17,361},{160,812},{171,529},{180,482},{454,600},{228,872},{204,492},{607,889},{86,79},{494,78},{442,404},{462,127},{935,402},{509,649},{458,941},{219,444},{306,57},{674,617},{79,652},{73,735},{900,756},{649,294},{982,754},{521,439},{356,265},{240,533},{865,44},{744,379},{97,454},{65,480},{544,191},{18,191},{503,38},{696,658},{61,884},{793,984},{383,364},{280,467},{888,662},{133,643},{365,512},{610,975},{98,584},{40,177},{548,102},{80,98},{986,951},{264,258},{583,734},{353,322},{427,551},{80,660},{273,609},{980,871},{739,802},{366,836},{55,509},{889,720},{857,661},{48,489},{119,26},{31,180},{472,673},{960,951},{383,500},{928,351},{848,705},{969,766},{311,714},{861,230},{34,596},{38,642},{1,955},{698,846},{784,791},{760,344},{677,239},{969,191},{539,644},{470,418},{289,357},{269,446},{668,245},{293,719},{937,103},{575,297},{874,656},{714,257},{934,396},{109,904},{89,635},{374,545},{316,587},{158,121},{901,969},{284,564},{666,568},{993,409},{370,637},{443,694},{576,160},{262,357},{590,729},{194,976},{743,376},{348,80},{669,527},{338,953},{236,785},{144,460},{438,457},{517,951},{545,647},{158,556},{905,591},{793,609},{571,643},{9,850},{581,490},{804,394},{635,483},{457,30},{42,621},{65,137},{424,864},{536,455},{59,492},{645,734},{892,571},{762,593},{608,384},{558,257},{692,420},{973,203},{531,51},{349,861},{804,649},{3,611},{6,468},{298,568},{651,767},{251,142},{173,974},{117,728},{326,562},{894,288},{814,555},{420,771},{20,775},{445,247},{243,592},{186,173},{101,800},{590,876},{515,534},{73,540},{333,215},{902,394},{640,787},{596,298},{984,712},{307,378},{540,646},{473,743},{340,387},{756,217},{139,493},{9,742},{195,25},{763,823},{451,693},{24,298},{645,595},{224,770},{976,41},{832,78},{599,705},{487,734},{818,134},{225,431},{380,566},{395,680},{294,320},{915,201},{553,480},{318,42},{627,94},{164,959},{92,715},{588,689},{734,983},{976,334},{846,573},{676,521},{449,69},{745,810},{961,722},{416,409},{135,406},{234,357},{873,61},{20,521},{525,31},{659,688},{424,554},{203,315},{16,240},{288,273},{281,623},{651,659},{939,32},{732,373},{778,728},{340,432},{335,80},{33,835},{835,651},{317,156},{284,119},{543,159},{719,820},{961,424},{88,178},{621,146},{594,649},{659,433},{527,441},{118,160},{92,217},{489,38},{18,359},{833,136},{470,897},{106,123},{831,674},{181,191},{892,780},{377,779},{608,618},{618,423},{180,323},{390,803},{562,412},{107,905},{902,281},{718,540},{16,966},{678,455},{597,135},{840,7},{886,45},{719,937},{890,173}};
        assert 35  == p.maxEnvelopes(envelopes5);


        int[][] envelopes3 = {{9,4},{19,9},{18,13},{3,19},{8,10},{6,14},{2,3},{6,7},{12,7},{12,15},{7,9},{10,1},{6,16},{13,19},{8,9},{4,2},{19,11},{2,9}};
        assert 6 == p.maxEnvelopes(envelopes3);

        int[][] envelopes = {{5,4}, {6,4}, {6,7}, {2,3}};
        assert 3 == p.maxEnvelopes(envelopes);

        int[][] envelopes2 = {{1,1}, {1,1}, {1,1}};
        assert 1 == p.maxEnvelopes(envelopes2);

        int[][] envelopes4 = {{4,5},{4,6},{6,7},{2,3},{1,1}};
        assert 4 == p.maxEnvelopes(envelopes4);
    }

}
